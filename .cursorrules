# Cooldown Reader — Project Context & Rules

## Project Overview
A Python desktop app that reads MMO action bar cooldowns via screen capture and image analysis.
It detects which abilities are ready/on cooldown/casting and can send keys based on configurable priority profiles.

## Architecture

### Core Loop (target 20-30 FPS on captured region)
```
Screen Capture (mss, small region only)
  → Slot Segmentation (crop each icon by computed pixel offsets from calibration)
    → Per-slot analysis:
        - Brightness/histogram delta vs baseline → cooldown yes/no
        - Optional OCR (EasyOCR) for countdown text
    → State dict per slot: { keybind, state, cooldown_remaining, slot_index }
      → UI visualization + automation engine (active priority profile)
```

### Module Responsibilities

- **src/capture/screen_capture.py** — Uses `mss` to grab a screen region at high FPS. Takes a bounding box (top, left, width, height) and monitor index. Returns numpy arrays.

- **src/analysis/slot_analyzer.py** — Takes a captured action bar image, segments it into individual icon slots (evenly spaced, with configurable slot count and gap pixels). For each slot, determines cooldown state.

- **src/analysis/ocr_engine.py** — Wraps EasyOCR (or Tesseract fallback). Handles the preprocessing pipeline: crop → upscale 3-4x → threshold → OCR. Two modes: keybind reading (top-right corner of slot) and cooldown number reading (center of slot).

- **src/overlay/calibration_overlay.py** — A transparent, always-on-top, click-through window (PyQt6) that draws a colored rectangle showing the current capture bounding box. Updates in real-time as the user adjusts values in the main UI. Must work over borderless-windowed games.

- **src/ui/main_window.py** — PyQt6 main control panel. Contains:
  - Start/stop capture + settings access
  - Live preview of what's being captured
  - Per-slot state visualization + keybind/context actions
  - Priority list editor (drag/drop) for the active automation profile
  - Last Action / Next Intention rows

- **src/automation/key_sender.py** — Sends keypresses based on slot states and priority order, with delay control, cast-aware blocking, queue timing, and optional target-window gating.
- **src/automation/global_hotkey.py** — Global bind listener and one-key capture helpers. Supports per-profile toggle/single-fire binds.

- **src/models/slot.py** — Dataclasses/enums for slot state and app config, including automation priority profiles and migration from legacy single-hotkey config.

- **config/default_config.json** — Persisted runtime defaults: capture/analysis settings, keybinds, baselines, and automation priority profiles.

### Key Technical Decisions

1. **Overlay approach**: PyQt6 frameless, transparent, always-on-top window with `Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.WindowTransparentForInput`. Draw with QPainter. The overlay is NOT draggable — position is controlled numerically from the main UI panel.

2. **Cooldown detection strategy (start simple, iterate)**:
   - Phase 1: Average brightness comparison. Capture each slot in "ready" state as baseline. Compare current brightness — if significantly darker, it's on cooldown. This alone gets you 80% of the way.
   - Phase 2: Add OCR for countdown numbers. Crop center region of slot, upscale, threshold, EasyOCR with allowlist='0123456789.'.
   - Phase 3: (Optional) Histogram or template matching for more precision.

3. **GCD detection**: Same visual as cooldown but ~1.5s duration. Needs fast polling. A slot that was ready → briefly dark → ready again within ~2s is a GCD, not a real cooldown. Consider a minimum cooldown threshold to distinguish.

4. **OCR performance**: EasyOCR model loading is slow (~2-3s). Load once at startup, reuse the reader instance. For keybind labels, read once and cache. For countdown numbers, only OCR slots that are detected as "on cooldown" by the brightness check first — don't OCR every slot every frame.

5. **Screen capture perf**: `mss` is fast but only capture the action bar region, never fullscreen. A ~400x50px region at 30fps is trivial.

6. **Threading model**: Capture + analysis loop runs in a worker thread (QThread). UI updates via signals/slots. Overlay updates via signal too. Never block the Qt event loop with capture work.

## Tech Stack
- Python 3.11+
- PyQt6 (UI + overlay)
- mss (screen capture)
- opencv-python (image processing)
- numpy (pixel math)
- easyocr (OCR, lazy-loaded)
- keyboard (global bind capture + key sending)
- dataclasses + json for config

## Coding Conventions
- Type hints on all function signatures
- Dataclasses for data structures
- Logging via `logging` module, not print()
- Config loaded from JSON, with runtime overrides
- Signals/slots for all cross-thread communication (no shared mutable state)
- Keep analysis pure-functional where possible: frame in → state out

## Current State
- Core capture/analyze/UI/automation flow is implemented and in use.
- Legacy config fields (`priority_order`, `automation_toggle_bind`, `automation_hotkey_mode`) are still serialized for compatibility.
- Preferred runtime model is `priority_profiles` + `active_priority_profile_id`.
- Settings automation section supports add/copy/remove profile actions and per-profile toggle/single-fire binds.

## Important Gotchas
- EasyOCR downloads models on first run (~100MB). Handle gracefully.
- On Windows, DPI scaling can mess up screen coordinates. Use `mss` monitor info which accounts for this, but test with scaling > 100%.
- Always-on-top over true exclusive fullscreen doesn't work — document that borderless windowed is required.
- Game fonts vary wildly. The keybind labels in the reference image are small and stylized. May need per-game OCR tuning or fallback to manual keybind entry.
- Cooldown brightness threshold will need per-game tuning. Expose it as a config slider.
